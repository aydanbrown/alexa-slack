var similar = require('string-similarity');

// function SessionMap(session) {
//   this.map = { channels: {}, member: {} };
//   // Map channels
//   if(session.channels) {
//     session.channels.forEach(function(channel) {
//       this.map.channels[channel.name] = channel;
//     });
//   }
//   // Map members
//   if(session.members) {
//     session.members.forEach(function(member) {
//       this.map.members[member.name] = member;
//     });
//   }
//   console.log('New SessionMap:');
//   console.log(this.map);
//   // Match string
//   this.match = function(string) {
//     var channelMatch = this.matchChannel(string);
//     var memberMatch = this.matchMember(string);
//     // TODO prompt for similar ratings
//     return channelMatch.rating > memberMatch.rating ? channelMatch : memberMatch;
//   }
//   this.matchChannel = function(string) {
//     var channels = [];
//     for(name in this.map.channels) {
//       channels.push(name);
//     }
//     var matches = similar.findBestMatch(string, channels);
//     return { type: 'channel', channel: this.map.channels[matches.bestMatch.target], rating: matches.bestMatch.rating };
//   }
//   this.matchMember = function(string) {
//     var members = [];
//     for(name in this.map.members) {
//       members.push(name);
//     }
//     var matches = similar.findBestMatch(string, members);
//     return { type: 'member', member: this.map.members[matches.bestMatch.target], rating: matches.bestMatch.rating };
//   }
//   return this;
// }

function buildSpeechlet(title, outputSpeech, repromptSpeech, shouldEndSession) {
  return {
    outputSpeech: {
      type: "PlainText",
      text: outputSpeech
    },
    card: {
      type: "Simple",
      title: "SessionSpeechlet - " + title,
      content: "SessionSpeechlet - " + outputSpeech
    },
    reprompt: {
      outputSpeech: {
        type: "PlainText",
        text: repromptSpeech
      }
    },
    shouldEndSession: shouldEndSession
  };
}

function buildSSML(title, outputSpeech, repromptSpeech, shouldEndSession) {
  var output = buildSpeechlet(title, outputSpeech, repromptSpeech, shouldEndSession);
  output.outputSpeech = { type: 'SSML', ssml: outputSpeech };
  output.reprompt.outputSpeech = { type: 'SSML', ssml: repromptSpeech };
  return output;
}

function buildErrorResponse(endSession) {
  return buildSpeechlet('Error', 'Sorry there was an issue with your request', 'Would you like anything else?', endSession);
}

module.exports = {
  buildSpeechlet: buildSpeechlet,
  buildSSML: buildSSML,
  buildErrorResponse: buildErrorResponse
  // SessionMap: SessionMap
}
