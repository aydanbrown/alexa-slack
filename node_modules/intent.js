var slack = require('slack')('xoxp-89670216483-89737576834-89670820275-f424ea0798674acb6f0b33f96f1760d5');
var similar = require('string-similarity');

var outputError = 'Sorry, there was an issue with your request, please try again';

exports.help = function(intent, session, next) {
  var outputSpeech = 'You can join a channel by saying join, then the channel name. ' +
  'You can send a message with say, followed by the message you want to send. ' +
  'Have fun slacking!';

  next(session.attributes, buildSpeechletResponse('Slack Help', outputSpeech, '', false));
}

exports.selectChannel = function(intent, session, next) {
  var channelSlot = intent.slots.Channel.value;
  var outputSpeech = '';

  console.log('selectChannel - Channel: ' + channelSlot);

  slack('channels.list', {}, function(err, res) {
    if(err) {
      console.error(err || !res.ok);

    } else if(!res.ok) {
      console.log('');
    } else {
      var channels = {};
      var comparison = [];
      res.channels.forEach(function(channel) {
        channels[channel.name] = channel;
        comparison.push(channel.name);
      });
      var matches = similar.findBestMatch(channelSlot, comparison);
      if(matches.bestMatch.rating < 0.5) {
        outputSpeech = 'Sorry, I couldn\'t find the channel you were looking for, please try again or ask for a list of channels';
      } else {
        session.attributes.channel = channels[matches.bestMatch.target];
        outputSpeech = 'You have joined the channel: ' + channels[matches.bestMatch.target].name;
        session.attributes.lastAction = { object: 'channel', action: 'join' };
      }
      console.log('Similar Channel: ' + matches.bestMatch.rating + ', '+ JSON.stringify(channels[matches.bestMatch.target], true, 3));
      next(session.attributes, buildSpeechletResponse('Select Channel', outputSpeech, '', false));
    }
  });
}

exports.sendMessageChannel = function(intent, session, next) {
  var messageSlot = intent.slots.Message;
  var outputSpeech = '';
  var repromptSpeech = 'Would you like anything else?';

  console.log('sendMessageChannel - Message: ' + messageSlot.value);

  if(session.attributes == null || session.attributes.channel == null) {
    outputSpeech = 'Sorry, you are not in a channel, say join, then the channel\'s name';
  } else {
    if(messageSlot) {
      slack('chat.postMessage', { username: 'Alexa', channel: session.attributes.channel.id, text: messageSlot.value }, function(err, result) {
        if(err) {
          console.error(err);
          outputSpeech = 'Sorry there was an issue with your request';
        } else if(!result.ok) {
          console.log('Slack not ok');
          console.log(JSON.stringify(result, true, 3));
          outputSpeech = 'Sorry there was an issue with Slack';
        } else {
          outputSpeech = 'Your message has been sent';
          session.attributes.lastAction = { object: 'channel', action: 'message' };
        }
        next(session.attributes, buildSpeechletResponse('Select Channel', outputSpeech, '', false));
      });
    }
  }
}

exports.readMessageChannel = function(intent, session, next) {
  var outputSpeech = '';

  if(session.attributes == null || session.attributes.channel == null) {
    outputSpeech = 'Sorry, you are not in a channel, say join, then the channel\'s name';
  } else {
    slack('channels.history', { channel: session.attributes.channel.id, count: 1 }, function(err, res) {
      if(err || !res.ok) {
        console.log('Error:');
        console.error(err);
        console.log(res);
        outputSpeech = outputError;
      } else if(res.messages.length == 0) {
        outputSpeech = 'Sorry, I couldn\'nt find any messages';
      } else {
        outputSpeech = res.messages[0].text;
      }
      next(session.attributes, buildSpeechletResponse('Read Message Channel', outputSpeech, '', false));
    })
  }
}

exports.listMessagesChannel = function(intent, session, next) {

}

function buildSpeechletResponse(title, output, repromptText, shouldEndSession) {
  return {
    outputSpeech: {
      type: "PlainText",
      text: output
    },
    card: {
      type: "Simple",
      title: "SessionSpeechlet - " + title,
      content: "SessionSpeechlet - " + output
    },
    reprompt: {
      outputSpeech: {
        type: "PlainText",
        text: repromptText
      }
    },
    shouldEndSession: shouldEndSession
  };
}
